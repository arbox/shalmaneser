require_relative 'xml_node'
require_relative 'string_terminals_in_right_order'
require 'common/RegXML'

#############
class SalsaTigerSentenceGraph < XMLNode
  include StringTerminalsInRightOrder

  attr_reader :node

  def initialize(xml_obj,     # RegXML object
                 sentence_id) # string: ID of this sentence

    # global data:
    # node: hash node_id -> XMLNode object
    #       maps node IDs to the nodes with that ID
    @node = Hash.new
    @sentence_id = sentence_id

    if xml_obj
      # we actually have syntactic information.
      # read it.

      # initialize this object as an XML node,
      # i.e. remember the outermost element's name, attributes,
      # and ID, and specify that it's not a text but an XML object
      super(xml_obj.name, xml_obj.attributes, sentence_id + "_graph", false)

      # initialize nodes, remember their IDs
      xml_obj.children_and_text.each { |child_or_text|

        case child_or_text.name
        when "terminals"
          make_nodes(child_or_text, "t", "s/graph/terminals", "all_children_kith")
        when "nonterminals"
          make_nodes(child_or_text, "nt", "s/graph/nonterminals")
        else
          # additional info that we don't need for now
          # keep for output
          add_kith(child_or_text)
        end
      }



      # add edges between nodes
      nonterminals = xml_obj.children_and_text.detect { |child| child.name == "nonterminals" }
      if nonterminals
        nonterminals.children_and_text.each { |nt|

          unless nt.name == "nt"
            # we've already done the warning bit in make_nodes
            next
          end

          syn_add_children(@node[SalsaTigerXmlNode.xmlel_id(nt)], nt)
        }
      end

    else
      # we have no syntactic information
      # record it anyway

      super("graph", {}, sentence_id + "_graph", false)
    end
  end


  ###
  def add_splitwords(xml_obj)  #RegXMl object
    unless xml_obj.nil?
      # splitwords is an XML element with name "splitwords" and
      # children named "splitword", each of which describes a split
      # for one of the terminals we already know
      xml_obj.children_and_text.each { |splitword|
        unless splitword.name() == "splitword"
          warn_child_ignored("s/sem/splitwords/", splitword)
          next
        end

        # make nodes for the splitword parts
        make_nodes(splitword, "part", "s/sem/splitwords/splitword", "all_children_kith")

        # this is the terminal that is being split:
        # add links to its new children
        syn_add_children(@node[SalsaTigerXmlNode.xmlel_id(splitword)], splitword)
      }
    end
  end

  ###
  def to_s
    string_for_nodes(syn_roots())
  end

  ###
  def get()
    # make sure that the graph element has a 'root' attribute
    # since the Salsa tool needs this
    set_attribute("root", syn_roots().first.id())
    super()
  end

  #####
  # access methods

  ###
  def each_node
    @node.each_value { |n|
      yield n
    }
  end

  ###
  def nodes
    return @node.values()
  end

  ###
  def each_terminal
    @node.each_value { |node|
      if node.is_terminal?
        yield node
      end
    }
  end

  ###
  def each_terminal_sorted
    sort_terminals_and_splitwords_left_to_right(terminals).each { |node_obj|
      yield node_obj
    }
  end

  ###
  def terminals
    return @node.values.select { |node| node.is_terminal? }
  end

  ###
  def terminals_sorted
    return  sort_terminals_and_splitwords_left_to_right(terminals)
  end

  ###
  def each_nonterminal
    @node.each_value { |node|
      if node.is_nonterminal?
        yield node
      end
    }
  end

  ###
  def nonterminals
    return @node.values.select { |node| node.is_nonterminal? }
  end

  ###
  def syn_roots
    return @node.values.select { |node|
      node.parent().nil?
    }
  end
  ###

  ######################3
  # adding nodes

  ###
  def add_child(arg1, arg2, varhash={})
    raise "Not implemented for this class"
  end

  ###
  def remove_child(arg1, arg2, varhash={})
    raise "Not implemented for this class"
  end

  ###
  def add_node(sentid,    # string: sentence ID
               label,     # string: t or nt
               cat = nil, # string: category
               word = nil,# string: word
               pos = nil, # string: part of speech
               syn_id = nil)   # string: ID for the new node

    unless ["t", "nt"].include? label
      raise "Unknown node label #{label} for new syntactic node. Must be either t or nt."
    end

    # make node ID: sentence ID plus ID generated by system time
    if syn_id
      new_id = sentid + "_" + syn_id
    else
      new_id = sentid + "_" + Time.new().to_f.to_s
    end

    elt = "<#{label}"
    [["id", new_id], ["cat", cat], ["word", word], ["pos", pos]].each { |label, content|
      if content
        elt << " #{label}=\"#{xml_secure_val(content)}\""
      end
    }
    elt << "/>"
    n = SynNode.new(RegXML.new(elt))
    @node[n.id] = n

    return n
  end

  ###
  def remove_node(node) # SynNode
    # remove node from list
    @node.delete(node.id)

    # remove it as child and parent of other nodes;
    # add its own children to the parent.
    # the _edgelabel_ of the new edges will be the edgeslabels
    # between the original node in its children
    # in other words, the label of the removed node's incoming edge
    # is deleted

#    STDERR.puts "Removing node #{node.id}:"

    pair = node.parent_with_edgelabel
    if pair
    # delete incoming edge for deleted node
      label, parent = pair
#      STDERR.puts "  Removing link from PARENT #{parent.id}, edgelabel #{label}"
      parent.remove_child(node, label)
    end
    # delete outgoing edge for deleted node
    node.each_child_with_edgelabel { |label, child|
      child.remove_parent(node, label)
#      STDERR.puts "  Removing link to child #{child.id}"
    }
    # glue deleted node's children to its parent
    if pair
      plabel, parent = pair
      node.each_child_with_edgelabel {|clabel,child|
        parent.add_child(child, clabel)
      }
#      STDERR.puts "Parent now has children "+node.parent.children.map {|c| c.id}.join(" ")
    end
  end

  ######################
  protected

  ###
  def get_xml_ofchildren()
    string = ""

    string << "<terminals>\n"
    each_terminal_sorted { |t|
      string << t.get()
    }
    string << "</terminals>\n"

    string << "<nonterminals>\n"
    each_nonterminal { |nt|
      string << nt.get()
    }
    string << "</nonterminals>\n"

    return string

  end

  def make_nodes(xml_obj,  # RegXML object
                 expected_obj_name, # string
                 where, # string
                 all_children_kith = nil) # object: if non-nil,
                                          # keep all children of the new nodes
                                          # as kith"

    xml_obj.children_and_text.each { |elt|

      if elt.name == expected_obj_name
        # this is the kind of child we were expecting to see
        n = SynNode.new(elt)
        @node[n.id] = n

        if all_children_kith
          elt.children_and_text.each { |elt_child|
            n.add_kith(elt_child)
          }
        end

      else
        warn_child_ignored(where, elt)
      end
    }
  end

  def syn_add_children(node,
                       xml_obj)
    unless node
      raise "Shouldn't be here"
    end

    xml_obj.children_and_text.each { |edge|

      if ["edge", "part"].include? edge.name()

        # add an edge to this child,
        # retrieve the node with the given ID from id_to_node
        child = @node[SalsaTigerXmlNode.xmlel_id(edge)]
        unless child
          raise "Sentence #{@sentence_id}: I cannot find a node for " + edge.to_s()
        end

        edgelabel = edge.attributes()["label"]
        node.add_child(child, edgelabel)

      elsif edge.name() == "other_edge"
        # add link to this node,
        # retrieve the node with the given ID from id_to_node
        child = @node[SalsaTigerXmlNode.xmlel_id(edge)]
        unless child
          raise "Sentence #{@sentence_id}: I cannot find a node for other_edge #{SalsaTigerXmlNode.xmlel_id(edge)} : " + edge.to_s()
        end

        attributes = edge.attributes()
        if attributes
          edgelabel = attributes.delete("label")
        else
          edgelabel = nil
        end
        node.add_link(child, edgelabel, attributes)

      else
        # something other than an edge
        # keep for output
        node.add_kith(edge)
      end
    }
  end
end
